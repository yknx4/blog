<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Shell on [ Y k N x ]</title>
    <link>//yknx4.github.io/blog/tags/shell/</link>
    <description>Recent content in Shell on [ Y k N x ]</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Fri, 28 Oct 2016 15:49:02 -0500</lastBuildDate>
    <atom:link href="//yknx4.github.io/blog/tags/shell/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Database branches with Git Hooks</title>
      <link>//yknx4.github.io/blog/article/database-branches-with-git-hooks/</link>
      <pubDate>Fri, 28 Oct 2016 15:49:02 -0500</pubDate>
      
      <guid>//yknx4.github.io/blog/article/database-branches-with-git-hooks/</guid>
      <description>

&lt;h3 id=&#34;the-problem&#34;&gt;The Problem&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;&lt;small&gt;You may skip to the solution part at the bottom if you feel brave&lt;/small&gt;&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Branching means you diverge from the main line of development and continue to do work without messing with that main line. - &lt;a href=&#34;https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell&#34; title=&#34;3.1 Git Branching - Branches in a Nutshell&#34;&gt;git&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Branches are one of the more powerful features of a VCS, you can work on new features and test changes without touching your master code. But many times those changes implies to do some changes on the database too, and well, your database certainly doesn&amp;rsquo;t live within your repository, so if you want to go back to master or to another branch you need to discard the changes you made to the database.&lt;/p&gt;

&lt;p&gt;For this you have many options:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;small&gt;Rails&lt;/small&gt;&lt;/em&gt; Rollback any migration you made&lt;/li&gt;
&lt;li&gt;Drop your db and create (or restore) a clean one &lt;strong&gt;&lt;em&gt;bye bye changes~&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Backup your current db and create (or restore a clean one) each time you switch branches so you have a standalone copy for each branch&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As we can see each of this options has it&amp;rsquo;s drawbacks&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;small&gt;Rails&lt;/small&gt;&lt;/em&gt; When you rollback your migrations you may lose any data that is not properly handled in the rollback, face the fact that some data is not easily recoverable or even worse, you may face the ugly and troublesome &lt;code&gt;ActiveRecord::IrreversibleMigration&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Dropping your db and creating a new one each time you need to switch to another branch can take a lot of time; specially when you have to download and import a production database dump with millions of records (&lt;em&gt;I&amp;rsquo;m working on a project in which this process easily takes about 20~ minutes&lt;/em&gt;), besides that you also loses any changes you did in your branch, changes that may take some extra time to regenerate when you go back to the branch you where working on.&lt;/li&gt;
&lt;li&gt;This one is the least dangerous for your data, the only drawback I can think of is that you may need quite a lot storage if your database is big. But it ain&amp;rsquo;t such a big trouble.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But the biggest drawbacks of all of this, is that none of them is automatic and you can easily forget to do it once and end up with a messed up &lt;code&gt;schema.rb&lt;/code&gt; in your &lt;code&gt;master&lt;/code&gt; branch. &lt;em&gt;Happened to me so many times before&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Luckily for us, Git gives us a way to do automated tasks whenever we change branches thanks to Git Hooks.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Git has a way to fire off custom scripts when certain important actions occur. There are two groups of these hooks: client-side and server-side. Client-side hooks are triggered by operations such as committing and merging, while server-side hooks run on network operations such as receiving pushed commits. - &lt;a href=&#34;https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks&#34; title=&#34;8.3 Customizing Git - Git Hooks&#34;&gt;git&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;the-solution&#34;&gt;The solution&lt;/h3&gt;

&lt;p&gt;Taking advantage of this hooks I made a &lt;a href=&#34;https://gist.github.com/yknx4/470ec4e1378a48382fdbaf6b5896f1d0&#34;&gt;script&lt;/a&gt; that automatically creates a backup of your currently active database and switch between backups whenever you switch branches.&lt;/p&gt;

&lt;h4 id=&#34;requirements&#34;&gt;Requirements&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;PostgreSQL (obviously)&lt;/li&gt;
&lt;li&gt;Git&lt;/li&gt;
&lt;li&gt;psql&lt;/li&gt;
&lt;li&gt;createdb&lt;/li&gt;
&lt;li&gt;dropbp&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ensure &lt;code&gt;git&lt;/code&gt;, &lt;code&gt;psql&lt;/code&gt;, &lt;code&gt;createdb&lt;/code&gt; and &lt;code&gt;dropdb&lt;/code&gt; are available in your path, also ensure you have a database user without password preferably named &lt;code&gt;postgres&lt;/code&gt;. (This should be the default setup in most of the development environments)&lt;/p&gt;

&lt;h4 id=&#34;installation&#34;&gt;Installation&lt;/h4&gt;

&lt;p&gt;Run the following commands in your projects root path  &lt;br /&gt; &lt;br /&gt;
1.- Download the script in your project&amp;rsquo;s hooks directory and make it executable&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; $ wget -O .git/hooks/post-checkout https://gist.githubusercontent.com/yknx4/470ec4e1378a48382fdbaf6b5896f1d0/raw/393a1faad80795631e08c994505f0a706404cedb/post-checkout
&amp;gt; $ chmod +x .git/hooks/post-checkout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.- Tweak the configuration &lt;br /&gt;
&lt;code&gt;&amp;gt; $ vim .git/hooks/post-checkout&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
# --- Constants
SEPARATOR=&amp;quot;/&amp;quot; # This is the separator that is going to be used to
MAIN_BACKUP=&amp;quot;_backup&amp;quot; # This is the suffix that is going to be used for a main backup
MAIN_DATABASE=&amp;quot;NAME_OF_YOUR_PROJECT_DB&amp;quot; # Here you should put the name of the db
DB_USER=&amp;quot;postgres&amp;quot; # In case your user is not postgres you may change it
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.- Thats all! You should have you database branches working now.&lt;/p&gt;

&lt;p&gt;Note: Due to the way branch information is passed to the hook, if you create branch A and then you create another branch B without making changes and then switch back to branch B it will actually not trigger a database backup because the hook will think branch B is branch A.&lt;/p&gt;

&lt;h3 id=&#34;how-it-works&#34;&gt;How it works?&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;some code has been trimmed to slim down the post size&lt;/em&gt;
In the first section of the script we just get the parameters received by the hook and assign them to variables, also we set the constants we are going to use throughout the script.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh

# --- Command line
PREVIOUS_HEAD=&amp;quot;$1&amp;quot;
NEW_HEAD=&amp;quot;$2&amp;quot;
IS_BRANCH_CHECKOUT=&amp;quot;$3&amp;quot;

# --- Constants
SEPARATOR=&amp;quot;/&amp;quot;
MAIN_BACKUP=&amp;quot;_backup&amp;quot;
MAIN_DATABASE=&amp;quot;awesome_project_db&amp;quot;
DB_USER=&amp;quot;postgres&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I defined some functions to make the code more readable. Most of these functions receive the database name as parameter, is important to know that all the names will be trimmed to 63 characters because that is a hard limit imposed by postgres for the database names. Some really long branches names may end up with colliding backup names.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# --- Functions
database_exists () {
  # logic to check if a database exists
}

kill_connections() {
  # logic to kill al the connections to the active db,
}

duplicate_database_to() {
  # logic to duplicate the main database to another one
}

drop_database() {
  # logic to drop a database
}

rename_database() {
  # logic to rename a database
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This alias makes the best guess about a branch name with the revision SHA&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alias branch_name=&#39;git name-rev --name-only&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I define these variables to have some useful information about git in a readable way&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# --- Variables
PREVIOUS_BRANCH=`branch_name $PREVIOUS_HEAD`
NEW_BRANCH=`git branch | grep -e &amp;quot;^*&amp;quot; | cut -d&#39; &#39; -f 2`
OLD_DATABASE=$MAIN_DATABASE$SEPARATOR$PREVIOUS_BRANCH
NEW_DATABASE=$MAIN_DATABASE$SEPARATOR$NEW_BRANCH
MAIN_BACKUP=$MAIN_DATABASE$MAIN_BACKUP
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here it comes the actual magic&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# --- Script

if [ $IS_BRANCH_CHECKOUT -eq 0 ]; then
  exit 0 # Exit script if it is not a branch change
fi

echo &amp;quot;Switching from $PREVIOUS_BRANCH to $NEW_BRANCH&amp;quot;
echo &amp;quot;Killing existing connections to $MAIN_DATABASE&amp;quot;
kill_connections # We need to kill all the connections or the commands here will fail

if ! database_exists $MAIN_BACKUP; then
  echo &amp;quot;Creating a main backup, if something goes wrong you can manually restore from this backup.&amp;quot;
  duplicate_database_to $MAIN_BACKUP # We should always have a master backup
fi

if [ &amp;quot;$PREVIOUS_BRANCH&amp;quot; == &amp;quot;$NEW_BRANCH&amp;quot; ]; then
  exit 0 # We didn&#39;t change branch, so lets just exit
fi

if database_exists $OLD_DATABASE; then
  # We need to remove old backups if they exists (they shouldn&#39;t most of the times) but
  # sometime when we didn&#39;t had changes in the branch when we created another one, so a
  # backup for the parent branch is created instead of one for the new branch, this is
  # to delete that wrong backup.
  drop_database $OLD_DATABASE
fi

if database_exists $NEW_DATABASE; then
  # When a backup for the new branch already exists
  # If there is already a backup for the branch we are checking to, lets just rename the active database to create a new backup
  rename_database $MAIN_DATABASE $OLD_DATABASE
  # and then lets rename the existing backup to the active database name
  rename_database $NEW_DATABASE $MAIN_DATABASE
else
  # If the branch we are checking to doesn&#39;t have a backup let&#39;s just copy the db to still have an active database
  duplicate_database_to $OLD_DATABASE
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I hope this is as useful as it was to me, switching to a new branch only takes about 15 seconds up from about 2 seconds, but refreshing my database from a production copy takes like 20 minutes so it&amp;rsquo;s manageable.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>